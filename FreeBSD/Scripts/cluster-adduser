#!/bin/sh -e

pause()
{
    printf "Press return to continue..."
    read junk
}

##########################################################################
#   Function description:
#       Determine the next available UID
#
#   History:
#   Date        Name        Modification
#   2012-11-26  Charlie &   Begin
##########################################################################

next_uid()
{
    # Start at 4000 to leave plenty of room for non-cluster user accounts
    uid=4000
    while uid_taken $uid; do
	uid=$((uid + 1))
    done
    printf "%s\n" $uid
}

uid_taken()
{
    # FIXME: Check all nodes, not just the head node, in case an account
    # was added outside cluster-admin
    local user_id=$1
    awk -F ':' ' { print $3 }' /etc/passwd | fgrep -q $user_id
    return $?
}

gid_taken()
{
    local group_id=$1
    awk -F ':' ' { print $3 }' /etc/group | fgrep -q $group_id
    return $?
}

user_exists()
{
    local user=$1
    if [ x$user = x ]; then
	return 1
    fi
    awk -F ':' ' { print $1 }' /etc/passwd | fgrep -q $user
    return $?
}

group_exists()
{
    local group=$1
    if [ x$group = x ]; then
	return 1
    fi
    awk -F ':' ' { print $1 }' /etc/group | fgrep -q $group
    return $?
}

if [ `whoami` != root ]; then
    printf "$0 must be run as root.\n"
    exit 1
fi

case $# in
0)
    user_name=''
    # FIXME: Check for illegal chars
    while [ x$user_name = x ]; do
	printf "Username? "
	read user_name
	if user_exists $user_name; then
	    printf "User $user_name already exists.\n"
	    user_name=''    # re-prime the loop
	fi
    done
    ;;
1)
    user_name=$1
    if user_exists $user_name; then
	printf "User $user_name already exists.\n"
	exit 1
    fi
    ;;
*)
    printf "Usage: $0 [username]\n"
    exit 1
    ;;
esac

if [ -e /usr/local/etc/ldap.conf ]; then
    # Flag usernames not in LDAP
    ldap_verified_uid=`ldapsearch uid=$user_name | awk '$1 == "uid:" { print $2 }'`
    if [ x$ldap_verified_uid != x$user_name ]; then
	printf "User $user_name is not in the LDAP directory.  Continue? (y/n) "
	read resp
	if [ x$resp != x'y' ]; then
	    exit 0
	fi
    fi
fi

printf "Primary group? [default = $user_name] "
read primary_group
if [ x$primary_group = x ]; then
    primary_group=$user_name
fi

printf "Other groups (separated by commas)? "
read othergroups

# Extract gecos info from ldap server
if [ -e /usr/local/etc/ldap.conf ]; then
    default_comment=`ldapsearch uid=$user_name | awk '$1 == "cn:" { for (c=2; c<NF; ++c) printf("%s ", $c); printf("%s", $NF); }'`
else
    default_comment=''
fi
comment=''
while [ x"$comment" = x ]; do
    printf "Comment? [default = '$default_comment'] "
    read comment
    if [ x"$comment" = x'' ]; then
	comment=$default_comment
    fi
done

# Determine user ID.  This should be specified in the useradd
# commands to ensure that it's the same on all nodes in the event that
# an account is mistakenly added to some nodes and not the rest.
valid=0
while [ $valid = 0 ]; do
    default_user_id=`next_uid`
    printf "User ID? [default = $default_user_id] "
    read user_id
    if [ x$user_id = x ]; then
	# Pick next uid after last line in /etc/passwd
	user_id=$default_user_id
	valid=1
    else
	if uid_taken $user_id; then
	    printf "User ID $user_id is already in use.\n"
	    valid=0
	else
	    valid=1
	fi
    fi
done

# If creating a new group, determine group ID.  This should be specified in
# the groupadd commands to ensure that it's the same on all nodes in the event
# that a group is mistakenly added to some nodes and not the rest.
if ! group_exists $primary_group; then
    valid=0
    while [ $valid = 0 ]; do
	default_primary_group_id=$default_user_id
	printf "Primary group ID? [default = $default_primary_group_id] "
	read primary_group_id
	if [ x$primary_group_id = x ]; then
	    # Pick next uid after last line in /etc/passwd
	    primary_group_id=$default_primary_group_id
	    valid=1
	else
	    if gid_taken $primary_group_id; then
		printf "Group ID $primary_group_id is already in use.\n"
		valid=0
	    else
		valid=1
	    fi
	fi
    done
    new_group=1     # Flag removal of group if subsequent useradd fails
else
    new_group=0
fi

# Select a shell for the new user
default_shell="/bin/tcsh"
valid=0
while [ $valid = 0 ]; do
    printf "\nValid shells:\n"
    fgrep -v '#' /etc/shells
    printf "/sbin/nologin\n"
    printf "\nShell? [$default_shell] "
    read shell
    if [ x$shell = x ]; then
	shell=$default_shell
	valid=1
    else
	if fgrep -q $shell /etc/shells || [ $shell = '/sbin/nologin' ]; then
	    valid=1
	else
	    valid=0
	    printf "$shell is not a valid shell.\n"
	fi
    fi
done

if [ $new_group = 1 ]; then
    # Construct command to create group
    groupadd_cmd="cluster-groupadd $primary_group"
    if [ x$user_id != x ]; then
	groupadd_cmd="$groupadd_cmd -g $primary_group_id"
    fi
    
    # Eval here to expand before running
    printf "$groupadd_cmd\n"
    eval $groupadd_cmd
fi

# Order of pw flags matters!
useradd_cmd="cluster-useradd $user_name $primary_group -w random"
if [ x$user_id != x ]; then
    useradd_cmd="$useradd_cmd -u $user_id"
fi
useradd_cmd="$useradd_cmd -c '$comment'"
if [ x$othergroups != x ]; then
    useradd_cmd="$useradd_cmd -G \"$othergroups\""
fi
useradd_cmd="$useradd_cmd -m -s $shell"

printf "$useradd_cmd\n"
if ! eval $useradd_cmd && [ $new_group = 1 ]; then
    cluster-run "pw groupdel $group"
    exit 1
fi

if [ x$user_name = x$ldap_verified_uid ]; then
    cat << EOM

This user can authenticate using either LDAP or the temporary password
shown above.  It is therefore optional to provide this temporary password
to the user.

EOM
else
    cat << EOM

Record the temporary password shown above.  This is the only means by which
this user can authenticate.

EOM
fi
pause

# Add links to /share*
for dir in /share[0-9]*; do
    if [ -e $dir ]; then    # for sets dir to '/shared[0-9]*' if no matches
	printf "Give $user_name access to ${dir}? (y/n) "
	read resp
	if [ x$resp = x'y' ]; then
	    mkdir -p $dir/Data/$user_name
	    chown ${user_name}:${user_name} $dir/Data/$user_name
	    # If $dir is on a ZFS filesystem, set quota
	    zfs_fs=`echo $dir | cut -c 2-`/Data
	    
	    if zfs list $zfs_fs 2> /dev/null; then
		default_quota=4G
		printf "Quota? [default = $default_quota] "
		read quota
		if [ x$quota = x ]; then
		    quota=$default_quota
		fi
		zfs set userquota@${user_name}=$quota $zfs_fs
	    else
		# Regular filesystem
		# edquota does not support suffixes like M, G, etc.
		default_quota=4000000
		printf "Quota? [default = $default_quota] "
		read quota
		if [ x$quota = x ]; then
		    quota=$default_quota
		fi
		edquota -e ${dir}:4000000:4000000 $user_name
	    fi
	    ln -s $dir/Data/$user_name /home/$user_name/Data
	fi
    fi
done

printf "Add user to email list(s) if necessary.\n"
pause

printf "Forward mail to? [none] "
read email
if [ 0$email != 0 ]; then
    dot_forward=/home/$user_name/.forward
    printf "$email\n" > $dot_forward
    chown ${user_name}:$user_name $dot_forward
    chmod 644 $dot_forward
fi

